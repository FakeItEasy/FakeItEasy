<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ include file="../CodeGen/Ordinals.ttinclude" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace FakeItEasy.Configuration
{
    using System;
#if FEATURE_NETCORE_REFLECTION
    using System.Reflection;
#endif

    public partial interface IOutAndRefParametersConfiguration<out TInterface>
    {
<# GenerateMethodDeclarations(); #>
    }

    internal partial class RuleBuilder
    {
        private const string NameOfOutRefLazilyFeature = "assigns out and ref parameters lazily";

<# GenerateMethodImplementations("IVoidConfiguration"); #>

        public partial class ReturnValueConfiguration<TMember>
        {
<# GenerateMethodImplementations("IReturnValueConfiguration<TMember>", "    "); #>
        }
    }

    internal partial class AnyCallConfiguration
    {
        private const string NameOfOutRefLazilyFeature = "assigns out and ref parameters lazily";

<# GenerateMethodImplementations("IVoidConfiguration"); #>
    }
}
<#+

void GenerateMethodDeclarations()
{
    for (int typeParametersCount = 1; typeParametersCount <= 8; typeParametersCount++)
    {
        var typeParamList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => "T" + i));
#>
        /// <summary>
        /// Specifies a function used to produce output values for out and ref parameters.
        /// The values should appear in the same order as the out and ref parameters in the configured call.
        /// Any non out and ref parameters are ignored.
        /// The function will be called each time this call is made and can return different values.
        /// </summary>
<#+
        for (int i = 1; i <= typeParametersCount; i++)
        {
#>
        /// <typeparam name="T<#= i #>">The type of the <#= Ordinals[i] #> argument of the faked method call.</typeparam>
<#+
        }
#>
        /// <param name="valueProducer">A function that produces the output values.</param>
        /// <returns>A configuration object.</returns>
        /// <exception cref="FakeConfigurationException">
        /// The signatures of the faked method and the <paramref name="valueProducer"/> do not match.
        /// </exception>
        IAfterCallConfiguredConfiguration<TInterface> AssignsOutAndRefParametersLazily<<#= typeParamList #>>(Func<<#= typeParamList #>, object?[]> valueProducer);

<#+
    }
}

void GenerateMethodImplementations(string configurationInterface, string indent = null)
{
    if (indent != null)
    {
        PushIndent(indent);
    }

    for (int typeParametersCount = 1; typeParametersCount <= 8; typeParametersCount++)
    {
        var typeParamList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => "T" + i));
        var argumentList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => $"call.GetArgument<T{i}>({i - 1})"));
#>
        /// <summary>
        /// Specifies a function used to produce output values for out and ref parameters.
        /// The values should appear in the same order as the out and ref parameters in the configured call.
        /// Any non out and ref parameters are ignored.
        /// The function will be called each time this call is made and can return different values.
        /// </summary>
<#+
        for (int i = 1; i <= typeParametersCount; i++)
        {
#>
        /// <typeparam name="T<#= i #>">The type of the <#= Ordinals[i] #> argument of the faked method call.</typeparam>
<#+
        }
#>
        /// <param name="valueProducer">A function that produces the output values.</param>
        /// <returns>A configuration object.</returns>
        /// <exception cref="FakeConfigurationException">
        /// The signatures of the faked method and the <paramref name="valueProducer"/> do not match.
        /// </exception>
        public IAfterCallConfiguredConfiguration<<#= configurationInterface #>> AssignsOutAndRefParametersLazily<<#= typeParamList #>>(Func<<#= typeParamList #>, object?[]> valueProducer)
        {
            Guard.AgainstNull(valueProducer, nameof(valueProducer));

            return this.AssignsOutAndRefParametersLazily(call =>
            {
                ValueProducerSignatureHelper.AssertThatValueProducerSignatureSatisfiesCallSignature(
                    call.Method, valueProducer.GetMethodInfo(), NameOfOutRefLazilyFeature);

                return valueProducer(<#= argumentList #>);
            });
        }

<#+
    }

    if (indent != null)
    {
        PopIndent();
    }
}
#>
