<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ include file="CodeGen/Ordinals.ttinclude" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace FakeItEasy
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using System.Threading.Tasks;
    using FakeItEasy.Configuration;

    public static partial class AsyncReturnValueConfigurationExtensions
    {
<#
    for (int typeParametersCount = 1; typeParametersCount <= 8; typeParametersCount++)
    {
        var typeParamList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => "T" + i));
        var lambdaParamList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => $"T{i} arg{i}"));
        var argumentList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => $"arg{i}"));
#>
        /// <summary>
        /// Returns a failed task with the specified exception when the currently configured call gets called.
        /// </summary>
        /// <param name="configuration">The configuration to use.</param>
        /// <param name="exceptionFactory">A function that returns the exception to set on the returned task when a call that matches is invoked.</param>
<#
        for (int i = 1; i <= typeParametersCount; i++)
        {
#>
        /// <typeparam name="T<#= i #>">The type of the <#= Ordinals[i] #> argument of the faked method call.</typeparam>
<#
        }
#>
        /// <returns>The configuration object.</returns>
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures", Justification = "This is by design to support the fluent API.")]
        public static IAfterCallConfiguredConfiguration<IReturnValueConfiguration<Task>> ThrowsAsync<<#= typeParamList #>>(
            this IReturnValueConfiguration<Task> configuration,
            Func<<#= typeParamList #>, Exception> exceptionFactory)
        {
            Guard.AgainstNull(configuration, nameof(configuration));
            Guard.AgainstNull(exceptionFactory, nameof(exceptionFactory));

            return
                configuration.ReturnsLazily(
                    (<#= lambdaParamList #>) => TaskHelper.FromException(exceptionFactory(<#= argumentList #>)));
        }

        /// <summary>
        /// Returns a failed task with the specified exception when the currently configured call gets called.
        /// </summary>
        /// <param name="configuration">The configuration to use.</param>
        /// <param name="exceptionFactory">A function that returns the exception to set on the returned task when a call that matches is invoked.</param>
        /// <typeparam name="T">The type of the returned task's result.</typeparam>
<#
        for (int i = 1; i <= typeParametersCount; i++)
        {
#>
        /// <typeparam name="T<#= i #>">The type of the <#= Ordinals[i] #> argument of the faked method call.</typeparam>
<#
        }
#>
        /// <returns>The configuration object.</returns>
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures", Justification = "This is by design to support the fluent API.")]
        public static IAfterCallConfiguredConfiguration<IReturnValueConfiguration<Task<T>>> ThrowsAsync<T, <#= typeParamList #>>(
            this IReturnValueConfiguration<Task<T>> configuration,
            Func<<#= typeParamList #>, Exception> exceptionFactory)
        {
            Guard.AgainstNull(configuration, nameof(configuration));
            Guard.AgainstNull(exceptionFactory, nameof(exceptionFactory));

            return configuration.ReturnsLazily((<#= lambdaParamList #>) => TaskHelper.FromException<T>(exceptionFactory(<#= argumentList #>)));
        }

<#
    }
#>
    }
}
